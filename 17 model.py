#Напишем функцию par_checker(string), которая проверяет строку string на корректность расстановки скобок.
def par_checker(string):
    stack = []  # инициализируем стек

    for s in string:  # читаем строку посимвольно
        if s == "(":  # если открывающая скобка,
            stack.append(s)  # добавляем её в стек
        elif s == ")":
            # если встретилась закрывающая скобка, то проверяем
            # пуст ли стек и является ли верхний элемент — открывающей скобкой
            if len(stack) > 0 and stack[-1] == "(":
                stack.pop()  # удаляем из стека
            else:  # иначе завершаем функцию с False
                return False
    # если стек пустой, то незакрытых скобок не осталось
    # значит, возвращаем True, иначе — False
    return len(stack) == 0

print(par_checker(str((5+6)*(7+8)/(4+3))))

#Модифицируйте функцию проверки баланса скобок для двух видов скобок: круглых и квадратных.

#Для реализации такого алгоритма может быть полезным создание словаря, в котором закрывающая скобка — ключ, открывающая — значение.
pars = {")": "(", "]": "["}


def par_checker_1(string):
    stack = []

    for s in string:
        if s == "([":
            stack.append(s)
        elif s == ")]":

            if len(stack) > 0 and stack[-1] == pars[s]:
                stack.pop()  # удаляем из стека
            else:
                return False

    return len(stack) == 0

print(par_checker_1(str(([2+3]))))

#Напишите функцию is_empty, которая проверяет наличие элементов в
# очереди, используя указатели head и tail. Запрещается использование функции
# len(list_), так как её сложность O(n).
def is_empty(): # очередь пуста?
    # да, если указатели совпадают и в них содержится ноль
    return head == tail and queue[head] == 0

#Напишите функцию size, которая возвращает текущий размер очереди.
# Учтите, что необходимо рассмотреть несколько случаев: когда очередь пустая,
# когда очередь полная (какому условию соответствует?), а также отдельное
# внимание стоит обратить на тот случай, когда хвост очереди переместился
# в начало списка (закольцевался).

def size(): # получаем размер очереди
    if is_empty(): # если она пуста
        return 0 # возвращаем ноль
    elif head == tail: # иначе, если очередь не пуста, но указатели совпадают
        return N_max # значит очередь заполнена
    elif head > tail: # если хвост очереди сместился в начало списка
        return N_max - head + tail
    else: # или если хвост стоит правее начала
        return tail - head



#«алгоритм Дейкстры»

G = {"Адмиралтейская" :
         {"Садовая" : 4},
     "Садовая" :
         {"Сенная площадь" : 3,
          "Спасская" : 3,
          "Адмиралтейская" : 4,
          "Звенигородская" : 5},
     "Сенная площадь" :
         {"Садовая" : 3,
          "Спасская" : 3},
     "Спасская" :
         {"Садовая" : 3,
          "Сенная площадь" : 3,
          "Достоевская" : 4},
     "Звенигородская" :
         {"Пушкинская" : 3,
          "Садовая" : 5},
     "Пушкинская" :
         {"Звенигородская" : 3,
          "Владимирская" : 4},
     "Владимирская" :
         {"Достоевская" : 3,
          "Пушкинская" : 4},
     "Достоевская" :
         {"Владимирская" : 3,
          "Спасская" : 4}}


D = {k : 100 for k in G.keys()} # расстояния
start_k = 'Адмиралтейская' # стартовая вершина
D[start_k] = 0 # расстояние от нее до самой себя равно нулю
U = {k : False for k in G.keys()} # флаги просмотра вершин
P = {k : None for k in G.keys()} # предки

pointer = "Владимирская" # куда должны прийти
while pointer is not None: # перемещаемся, пока не придём в стартовую точку
    print(pointer)
    pointer = P[pointer]

for _ in range(len(D)):
    # выбираем среди непросмотренных наименьшее по расстоянию
    min_k = min([k for k in U.keys() if not U[k]], key = lambda x: D[x])

    for v in G[min_k].keys(): # проходимся по всем смежным вершинам
         if D[v] > D[min_k] + G[min_k][v]: # если расстояние от текущей вершины меньше
            D[v] = D[min_k] + G[min_k][v] # то фиксируем его
            P[v] = min_k # и записываем как предок
    U[min_k] = True # просмотренную вершину помечаем

pointer = "Владимирская" # куда должны прийти
while pointer is not None: # перемещаемся, пока не придём в стартовую точку
    print(pointer)
    pointer = P[pointer]

